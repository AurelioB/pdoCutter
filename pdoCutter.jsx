#include ".extendables/extendables.jsx"(function() {    var ui = require("ui");    var here = new File($.fileName).parent;    var dialog = null;    main();    function main() {        dialog = createDialog();        dialog.window.show();        //var settings = new Preferences();        //app.preferences.setStringPreference("defaultTemplate", "test");        //alert(app.preferences.getStringPreference("defaultTemplate", "test"));    }    function createDialog() {        var styles = getStyles();        var dialog = new ui.Dialog("pdoCutter").with(styles);        dialog.window.onActivate = function() {            this.size = styles.dialog.size;            this.layout.resize();        };        dialog.window.onResize = function() {            dialog.window.onActivate();            this.center();        };        var normalFont = ScriptUI.newFont("Arial","REGULAR",13);        dialog.row("filesRow").using("filesRow");        dialog.filesRow.column("buttons").using("fileButtonsColumn")            .button("selectPDFButton", "PDF file").using("selectPDFButton")                .using("fileButtons")        dialog.filesRow.column("inputs").using("fileInputsColumn")            .input("PDFPath", "")                .using("fileInputs")        dialog.panel("templatePanel").using("templatePanel")            .dropdown("template", getTemplatesList()).using("template");        dialog.templatePanel.template.selection = 0;        dialog.panel("rangePanel", [undefined, "Page Range"]).using("rangePanel")            .text("rangeFromLabel", "From:")            .input("rangeFrom", "1").using("rangeInputs")            .text("rangeToLabel", "To:")            .input("rangeTo", "1").using("rangeInputs");        dialog.panel("progressPanel").using("progressPanel")            .progressbar("progress").using("progress");        dialog.row('actions')            .button('cancel', "Cancel")            .button('start', "Start").using("startButton");        dialog.filesRow.buttons.selectPDFButton.graphics.font = normalFont;        dialog.filesRow.inputs.PDFPath.graphics.font = normalFont;        dialog.templatePanel.template.graphics.font = normalFont;        dialog.rangePanel.rangeFromLabel.graphics.font = normalFont;        dialog.rangePanel.rangeFrom.graphics.font = normalFont;        dialog.rangePanel.rangeToLabel.graphics.font = normalFont;        dialog.rangePanel.rangeTo.graphics.font = normalFont;        dialog.actions.cancel.graphics.font = normalFont;        dialog.actions.start.graphics.font = normalFont;        dialog.filesRow.buttons.selectPDFButton.onClick = function() {            dialog.actions.start.enabled = false; // disable the Ok button            var PDFFile = File.openDialog("Select PDF...", "*.pdf"); // get the file            if(PDFFile) {                PDFFile = new File(PDFFile.fsName.replace("file://","")); // Lion fix by John Hawkinson                // check if it is valid file, it should be, unless after clicking a file, the name gets edited                if(PDFFile.exists) {                    var PDFInfo = getPDFInfo(PDFFile, true);                    dialog.filesRow.inputs.PDFPath.text = PDFFile.fsName; // show the file Path here                    dialog.rangePanel.rangeTo.text = PDFInfo.pgCount;                    dialog.rangePanel.rangeTo.active = true;                    dialog.actions.start.enabled = true; // enable the Ok button                }            }         };        dialog.actions.cancel.onClick = function() {            this.window.close();        };        dialog.actions.start.onClick = function() {            if(dialog.rangePanel.rangeTo.text < dialog.rangePanel.rangeFrom.text) {                alert("Please enter a valid page range");                return;            }            var PDFFile = File(dialog.filesRow.inputs.PDFPath.text);            dialog.progressPanel.progress.enabled = true;            dialog.progressPanel.progress.maxvalue = dialog.rangePanel.rangeTo.text - dialog.rangePanel.rangeFrom.text + 1;            var templateFile = null;            if(dialog.templatePanel.template.selection != null) {                templateFile = getTemplateFile();            }            processFile(PDFFile, templateFile, dialog.rangePanel.rangeFrom.text, dialog.rangePanel.rangeTo.text);        };        return dialog;    }    function getTemplatesList() {        var templatesFolder = new Folder("templates").at(here);        var templates = templatesFolder.files();        var templatesList = [];        templates.forEach(function(template) {            templatesList.push(template.name);        });        return templatesList;    }    function getTemplateFile() {        var fileName = dialog.templatePanel.template.selection.text;        var templatesFolder = new Folder("templates").at(here);        var templateFile = new File(fileName).at(templatesFolder);        return templateFile;    }    function setProgress(fromPage, page) {        dialog.progressPanel.progress.value = page - fromPage + 1;    }    function getStyles() {        return {            dialog: {                size: {                    width: 500,                    height: 300                }            },            filesRow: {                //preferredSize: [400, ""]                alignment: ["fill", ""]            },            filesColumns: {                justify: "right"            },            fileButtonsColumn: {                preferredSize: [150, ""]            },            fileInputsColumn: {                preferredSize: [310, ""],                alignChildren: ["right", "center"]            },            fileButtons: {                alignment: ["fill", "fill"]            },            selectPDFButton: {                helpTip: "PDF file exported from Pepakura (lines must be printed as vectors)"            },            selectTemplateButton: {                helpTip: "Template with registration marks to be copied"            },            fileInputs: {                alignment: ["fill","fill"]            },            templatePanel: {                alignment: ["fill", ""],                text: "Registration Marks Template"            },            template: {                alignment: ["fill", ""]            },            startButton: {                enabled: false            },            rangePanel: {                size: ["", 50],                orientation: "row",                alignment: ["fill",""],                text: "Page Range",                alignChildren: "right"            },            rangeInputs: {                preferredSize: [50, ""],                alignment: ["","fill"]            },            progressPanel: {                alignment: ["fill",""],                text: "Progress"            },            progress: {                enabled: false,                alignment: ["fill","fill"]            }        };    }    function processFile(PDFFile, templateFile, fromPage, toPage) {        app.userInteractionLevel = UserInteractionLevel.DONTDISPLAYALERTS;        var outputFolder = new Folder("silhouette").at(PDFFile.parent);        if (!outputFolder.exists) {            outputFolder.create();        }        var cutFolder = new Folder("cut").at(outputFolder);        if (!cutFolder.exists) {            cutFolder.create();        }        var PDFFileName = PDFFile.name;        PDFFileName = PDFFileName.substr(0, PDFFileName.length - 4);        // Open the new file        var outputPDFFile = new File(outputPDFFileName);        var PDFOptions = app.preferences.PDFFileOptions;        var width = 0;        var height = 0;        var pathsDoc = "";        //var templateDoc = open(templateFile, DocumentColorSpace.RGB);        for(var page = fromPage; page <= toPage; page++) {            var cutFileName = cutFolder.absoluteURI + "/" + page + ".ai";            if(!templateFile.copy(cutFileName)) {                alert("It seems the directory you're trying to write to isn't writable. Please move your files to another directory and try again.");                return;            }            var cutFile = new File(cutFileName);            // Open the new file            var outputPDFFileName = outputFolder.fullName + "/" + PDFFileName + "_" + page + ".pdf";            var outputPDFFile = new File(outputPDFFileName);            PDFOptions.pageToOpen = page;            // Open the pdf page            var doc = open(PDFFile, DocumentColorSpace.RGB);            doc.name = PDFFileName + "_" + page;            if(width == 0 || height == 0) {                width = doc.width;                height = doc.height;            }            //var cutDoc = app.documents.add(DocumentColorSpace.RGB, width, height);            var cutDoc = open(cutFile, DocumentColorSpace.RGB);            var sourceLayer = doc.layers[0];            var tempLayer = doc.layers.add();            tempLayer.name = "Temp";            var texturesLayer = cutDoc.layers.add();            texturesLayer.name = "Textures";            var cutLinesLayer = cutDoc.layers.add();            cutLinesLayer.name = "Cutlines";            var pathsGroup = tempLayer.groupItems.add();            pathsGroup.name = "Paths";            var imagesGroup = tempLayer.groupItems.add();            imagesGroup.name = "Images";            try {                for(var i = sourceLayer.groupItems.length - 1; i >= 0; i--) {                    var group = sourceLayer.groupItems[i];                    if(group.clipped == true) {                        if(group.rasterItems.length) {                            group.rasterItems[0].move(imagesGroup, ElementPlacement.PLACEATBEGINNING);                        }                    }                }                for(var i = sourceLayer.pathItems.length - 1; i >= 0; i--) {                    var path = sourceLayer.pathItems[i];                    if(path.length) {                        path.move(pathsGroup, ElementPlacement.PLACEATBEGINNING);                    }                }                imagesGroup.duplicate(texturesLayer, ElementPlacement.PLACEATBEGINNING);                pathsGroup.duplicate(cutLinesLayer, ElementPlacement.PLACEATBEGINNING);                setProgress(fromPage, page);                cutDoc.close(SaveOptions.SAVECHANGES);                doc.close(SaveOptions.DONOTSAVECHANGES);            } catch(e) {                alert(e);            }        }        var cutFiles = cutFolder.getFiles();        var printDoc = app.documents.add(DocumentColorSpace.RGB, width, height, cutFiles.length, DocumentArtboardLayout.Row);        for(var i = toPage; i >= fromPage; i--) {            var cutFile = cutFiles[i - 1];            var newPage = printDoc.placedItems.add();            newPage.file = cutFile;            newPage.name = "Page " + (index + 1);            var rect = printDoc.artboards[index].artboardRect;            newPage.left = rect[0] +  (width - newPage.width) / 2;            newPage.top = rect[1] - (height - newPage.height) / 2;            setProgress(fromPage, index + 1);        }        var printFile = new File("print.pdf").at(outputFolder);        var PDFSaveOptions = getPDFOptions();        printDoc.saveAs(printFile, PDFSaveOptions);        printDoc.close(SaveOptions.DONOTSAVECHANGES);        app.userInteractionLevel = UserInteractionLevel.DISPLAYALERTS;    }    /*********************************************************    getPDFOptions: Function to set the PDF saving options of the    files using the PDFSaveOptions object.    **********************************************************/    function getPDFOptions() {        // Create the PDFSaveOptions object to set the PDF options        var options = new PDFSaveOptions();        // Setting PDFSaveOptions properties. Please see the JavaScript Reference        // for a description of these properties.        // Add more properties here if you like        options.acrobatLayers = true;        options.preserveEditability = false;        options.monochromeCompression = MonochromeCompression.CCIT4;        //options.colorBars = true;        options.colorCompression = CompressionQuality.AUTOMATICJPEGHIGH;        options.compressArt = true; //default        options.embedICCProfile = true;        options.enablePlainText = true;        options.generateThumbnails = true; // default        options.optimization = true;        //options.pageInformation = true;        // uncomment to view the pdfs after conversion.        // options.viewAfterSaving = true;        return options;    }    // Extract info from the PDF file.    // getSize is a boolean that will also determine page size and rotation of first page    // *** File position changes in this function. ***    // Results are as follows:    // page count = retArray.pgCount    // page width = retArray.pgSize.pgWidth    // page height = retArray.pgSize.pgHeight    function getPDFInfo(pdfFile, getSize) {        var flag = 0; // used to keep track if the %EOF line was encountered        var nlCount = 0; // number of newline characters per line (1 or 2)        // The array to hold return values        var retArray = new Array();        retArray["version"] = -1;        retArray["pgCount"] = -1;        retArray["pgSize"] = null;        // Open the PDF file for reading        pdfFile.open("r");        // Get the pdf version        var sVersion = pdfFile.readln();        // Make sure this is a PDF        if (sVersion.substr(0, 4) != "%PDF") {            throwError("A PDF file must be chosen. Quitting...", false, 1, pdfFile);            return;        }        // Save the version number        retArray["version"] = parseFloat(sVersion.substr(5, sVersion.length));        // Search for %EOF line        // This skips any garbage at the end of the file        // if FOE% is encountered (%EOF read backwards), flag will be 15        for(i=0; flag != 15; i++){            pdfFile.seek(i,2);            switch(pdfFile.readch()){                case "F":                    flag|=1;                    break;                case "O":                    flag|=2;                    break;                case "E":                    flag|=4;                    break;                case "%":                    flag|=8;                    break;                default:                    flag=0;                    break;            }        }        // Jump back a small distance to allow going forward more easily        pdfFile.seek(pdfFile.tell()-100);        // Read until startxref section is reached        while(pdfFile.readln() != "startxref");        // Set the position of the first xref section        var xrefPos = parseInt(pdfFile.readln(), 10);        // The array for all the xref sections        var xrefArray = new Array();        // Go to the xref section        pdfFile.seek(xrefPos);        // Get all the xref sections        while(xrefPos != -1){            // Go to next section            pdfFile.seek(xrefPos);            // Make sure it's an xref line we went to, otherwise PDF is no good            var xrefLine = pdfFile.readln();            if (xrefLine != "xref"){                throwError("Cannot determine page count.", true, 99, pdfFile);                return;            }            // Add the current xref section into the main array            xrefArray[xrefArray.length] = makeXrefEntry(pdfFile);            // See if there are any more xref sections            xrefPos = xrefArray[xrefArray.length-1].prevXref;        }        // Go get the location of the /Catalog section (the /Root obj)        var objRef = -1;        for(i=0; i < xrefArray.length; i++){            objRef = xrefArray[i].rootObj;            if(objRef != -1){                i = xrefArray.length;            }        }        // Double check root obj was found        if(objRef == -1){            throwError("Unable to find Root object.", true, 98, pdfFile);            return;        }        // Get the offset of the root section and set file position to it        var theOffset = getByteOffset(pdfFile, objRef, xrefArray);        pdfFile.seek(theOffset);        // Determine the obj where the first page is located        objRef = getRootPageNode(pdfFile);        // Get the offset where the root page node is located and set the file position to it        theOffset = getByteOffset(pdfFile, objRef, xrefArray);        pdfFile.seek(theOffset);        // Get the page count info from the root page tree node section        retArray.pgCount = readPageCount(pdfFile);        // Does user need size also? If so, get size info        if(getSize){            // Go back to root page tree node            pdfFile.seek(theOffset);            // Flag to tell if page tree root was visited already            var rootFlag = false;            // Loop until an actual page obj is found (page tree leaf)            do{                var getOut = true;                if(rootFlag){                    // Try to find the line with the /Kids entry                    // Also look for instance when MediBox is in the root obj                    do{                        var tempLine = pdfFile.readln();                    }while(tempLine.indexOf("/Kids") == -1 && tempLine.indexOf(">>") == -1);                }                else{                    // Try to first find the line with the /MediaBox entry                    rootFlag = true; // Indicate root page tree was visited                    getOut = false; // Force loop if /MediaBox isn't found here                    do{                        var tempLine = pdfFile.readln();    //                  $.write("norootflag tempLine: " + tempLine);                        if(tempLine.indexOf("/MediaBox") != -1){                            getOut = true;                            break;                        }                    }while(tempLine.indexOf(">>") == -1);                    if(!getOut){                        // Reset the file pointer to the beginning of the root obj again                        pdfFile.seek(theOffset)                    }                }                // If /Kids entry was found, still at an internal page tree node                if(tempLine.indexOf("/Kids") != -1){                    // Check if the array is on the same line                    if(tempLine.indexOf("R") != -1){                        // Grab the obj ref for the first page                        objRef = parseInt(tempLine.split("/Kids")[1].split("[")[1]);                    }                    else{                        // Go down one line                        tempLine = pdfFile.readln();                        // Check if the opening bracket is on this line                        if(tempLine.indexOf("[") != -1){                            // Grab the obj ref for the first page                            objRef = parseInt(tempLine.split("[")[1]);                        }                        else{                            // Grab the obj ref for the first page                            objRef = parseInt(tempLine);                        }                    }                    // Get the file offset for the page obj and set file pos to it                    theOffset = getByteOffset(pdfFile, objRef, xrefArray);                    pdfFile.seek(theOffset);                    getOut = false;                }            }while(!getOut);            // Make sure file position is correct if finally at a leaf            pdfFile.seek(theOffset);            // Go get the page sizes            retArray.pgSize = getPageSize(pdfFile);        }        // Close the PDF file, finally all done!        pdfFile.close();        return retArray;    }    // Function to create an array of xref info    // File position must be set to second line of xref section    // *** File position changes in this function. ***    //function makeXrefEntry(pdfFile, lineLen){    function makeXrefEntry(pdfFile) {        var newEntry = new Array();        newEntry["theSects"] = new Array();        var temp = pdfFile.readln();        // Save info        newEntry.theSects[0] = makeXrefSection(temp, pdfFile.tell());        // Try to get to trailer line        var xrefSec = newEntry.theSects[newEntry.theSects.length-1].refPos;        var numObjs = newEntry.theSects[newEntry.theSects.length-1].numObjs;        var tempLine;        do {            tempLine = pdfFile.readln();        } while(tempLine.indexOf("trailer") == -1)        // Read line with trailer dict info in it        // Need to get /Root object ref        newEntry["rootObj"] = -1;        newEntry["prevXref"] = -1;        do{            temp = pdfFile.readln();            if(temp.indexOf("/Root") != -1){                // Extract the obj location where the root of the page tree is located:                newEntry.rootObj = parseInt(temp.substring(temp.indexOf("/Root") + 5), 10);            }            if(temp.indexOf("/Prev") != -1){                newEntry.prevXref = parseInt(temp.substring(temp.indexOf("/Prev") + 5), 10);            }        }while(temp.indexOf(">>") == -1);        return newEntry;    }    // Function to save xref info to a given array    function makeXrefSection(theLine, thePos) {        var tempArray = new Array();        var temp = theLine.split(" ");        tempArray["startObj"] = parseInt(temp[0], 10);        tempArray["numObjs"] = parseInt(temp[1], 10);        tempArray["refPos"] = thePos;        return tempArray;    }    // Function to extract the sizes from a page reference section    // File position must be at the start of the page object    // *** File position changes in this function. ***    function getPageSize(pdfFile){        var hasTrimBox = false; // Prevent MediaBox from overwriting TrimBox info        var charOffset = -1;        var isRotated = false; // Page rotated 90 or 270 degrees?        var foundSize = false; // Was a size found?        var outCount = 0; // keeps track of << >> pairs encountered for PDF version 1.6+        var gotIn = false;        do{            var theLine = pdfFile.readln();            if(!hasTrimBox && (charOffset = theLine.indexOf("/MediaBox")) != -1){                // Is the array on the same line?                if(theLine.indexOf("[", charOffset + 9) == -1){                    // Need to go down one line to find the array                    theLine = pdfFile.readln();                    // Extract the values of the MediaBox array (x1, y1, x2, y2)                    var theNums = theLine.split("[")[1].split("]")[0].split(" ");                }                else{                    // Extract the values of the MediaBox array (x1, y1, x2, y2)                    var theNums = theLine.split("/MediaBox")[1].split("[")[1].split("]")[0].split(" ");                }                // Take care of leading space                if(theNums[0] == ""){                    theNums = theNums.slice(1);                }                foundSize = true;            }            if((charOffset = theLine.indexOf("/TrimBox")) != -1){                // Is the array on the same line?                if(theLine.indexOf("[", charOffset + 8) == -1){                    // Need to go down one line to find the array                    theLine = pdfFile.readln();                    // Extract the values of the MediaBox array (x1, y1, x2, y2)                    var theNums = theLine.split("[")[1].split("]")[0].split(" ");                }                else{                    // Extract the values of the MediaBox array (x1, y1, x2, y2)                    var theNums = theLine.split("/TrimBox")[1].split("[")[1].split("]")[0].split(" ");                }                // Prevent MediaBox overwriting TrimBox values                hasTrimBox = true;                // Take care of leading space                if(theNums[0] == ""){                    theNums = theNums.slice(1);                }                foundSize = true;            }            if((charOffset = theLine.indexOf("/Rotate") ) != -1){                var rotVal = parseInt(theLine.substring(charOffset + 7));                if(rotVal == 90 || rotVal == 270){                    isRotated = true;                }            }            if ((charOffset = theLine.indexOf("<<")) != -1){                outCount++;                gotIn = true;            }            if ((charOffset = theLine.indexOf(">>")) != -1){                outCount--;            }        }while(!gotIn || (outCount != 0));        // Check if a size array wasn't found        if(!foundSize){            throwError("Unable to determine PDF page size.", true, 96, pdfFile);        }        // Do the math        var xSize =  parseFloat(theNums[2]) - parseFloat(theNums[0]);        var ySize =  parseFloat(theNums[3]) - parseFloat(theNums[1]);        // One last check that sizes are actually numbers        if(isNaN(xSize) || isNaN(ySize)){            throwError("One or both page dimensions could not be calculated.", true, 95, pdfFile);        }        // Use rotation to determine orientation of pages        var ret = new Array();        ret["width"] = isRotated ? ySize : xSize;        ret["height"] = isRotated ? xSize : ySize;        return ret;    }    // Function that determines the byte offset of an object number    // Searches the built array of xref sections and reads the offset for theObj    // *** File position changes in this function. ***    function getByteOffset(pdfFile, theObj, xrefArray) {        var theOffset = -1;        // Look for the theObj in all sections found previously        for(i = 0; i < xrefArray.length; i++){            var tempArray = xrefArray[i];            for(j=0; j < tempArray.theSects.length; j++){                 var tempArray2 = tempArray.theSects[j];                // See if theObj falls within this section                if(tempArray2.startObj <= theObj && theObj <= tempArray2.startObj + tempArray2.numObjs -1){                    pdfFile.seek(tempArray2.refPos);                    for(k = 0; k < (theObj-tempArray2.startObj); k++)                        pdfFile.readln();                    // Get the location of the obj                    var tempLine = pdfFile.readln();                    // Check if this is an old obj, if so ignore it                    // An xref entry with n is live, with f is not                    if(tempLine.indexOf("n") != -1){                        theOffset = parseInt(tempLine, 10);                        // Cleanly get out of both loops                        j = tempArray.theSects.length;                        i = xrefArray.length;                    }                }            }        }        return theOffset;    }    // Function to extract the root page node object from a section    // File position must be at the start of the root page node    // *** File position changes in this function. ***    function getRootPageNode(pdfFile) {        var tempLine = pdfFile.readln();        // Go to line with /Page token in it        while(tempLine.indexOf("/Pages") == -1){            tempLine = pdfFile.readln();        }        // Extract the root page obj number        return parseInt(tempLine.substring(tempLine.indexOf("/Pages") + 6), 10);    }    // Function that gets the page count form a root page section    // *** File position changes in this function. ***    function readPageCount(pdfFile){        // Read in first line of section        var theLine = pdfFile.readln();        // Locate the line containing the /Count entry        while(theLine.indexOf("/Count") == -1){            theLine = pdfFile.readln();        }        // Extract the page count        return parseInt(theLine.substring(theLine.indexOf("/Count") +6), 10);    }    // Error function    function throwError(msg, includeResave, idNum, fileToClose){        var RESAVE = "\n\nPlease open the PDF file in Acrobat, do a \"Save As...\" and try again.";        alert("ERROR: " + msg + ((includeResave) ? RESAVE : ""), "Multi-page PDF Script Error");        if(fileToClose != null){            fileToClose.close();        }    }})();